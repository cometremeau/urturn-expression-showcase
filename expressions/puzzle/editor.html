<canvas id='c' width='640' height='720' style='width:100%'> 

</canvas>

<div id='cache' style='width : 100%; height : 100%; opacity : 0.9; background-color:#aaa; position : absolute; top : 0px; left : 0px'>
</div>
<div id='tuto' style='position : absolute; width : 90%; top : 5%; left : 5%' class='box'>
  <div class='tutorial'>
    <h1>How to edit a level?</h1>

    <p>
      <img src='assets/tuto_editor_1.png' /><br/>
      Click on / touch the grid to add a piece.
    </p>
    <p>
      <img src='assets/tuto_editor_2.png' /><br />
      Click on / touch a color on the pallette to change current color.
    </p>
    <p>
       <img src='assets/tuto_editor_3.png' /><br />
      Click on / touch reroll to change the pallette.
    </p>
    <input type='button' value='Start to edit now !' class='btn success big' onclick='startEditing()' />
    <br/>
  </div>
</div>


<script type="text/javascript">
  var post = null;
  // Bootstrap you expression editor
  UT.Expression.ready(function(exp){
    post = exp;
  });


  function saveMap() {
    post.storage.map = JSON.stringify(MAP);
    post.storage.save();
    post.valid(true);
  }

  function startEditing() {
    document.getElementById('cache').style.display = 'none';
    document.getElementById('tuto').style.display = 'none';
  }
  

  var canvas = document.getElementById('c');
  var ctx = canvas.getContext('2d');
  var WIDTH = 640;
  var HEIGHT = 720;
  var COLOR_INDEX = 0;

  var COLORS = [
    '#221e23',
    '#382834',
    '#573847',
    '#66464F',
    '#705351',
    '#8A6D60',
    '#BDA488',
    '#e8d9b7'
  ];

 
  function generatePalette() {

    
    var START = [];
    var END = [];
    var s = 0;
    var m = 0;
    while (s < 256 || m < 90) {
      START = [Math.random() * 128 | 0, Math.random() * 128 | 0, Math.random() * 128 | 0];
      END = [128 + Math.random() * 128 | 0, 128 + Math.random() * 128 | 0, 128 + Math.random() * 128 | 0];
      s = Math.abs(START[0] - END[0]) + Math.abs(START[1] - END[1]) + Math.abs(START[2] - END[2]) ;
      m = Math.max(Math.abs(START[0] - END[0]) ,Math.abs(START[1] - END[1]) , Math.abs(START[2] - END[2]));
    }
    var dr = (END[0] - START[0]) / 8;
    var dg = (END[1] - START[1]) / 8;
    var db = (END[2] - START[2]) / 8;


    var r = START[0];
    var g = START[1];
    var b = START[2];

    var i = 0;
    while (i < 8) {
      COLORS[i] = "rgb(" + (r | 0) + "," + (g | 0) + ","+ (b | 0) + ")";
      r += dr;
      g += dg;
      b += db;
      ++i;
    }
  }
  generatePalette();

  var COLOR = 0;

  var MAP = [];
  var SCHEMA_MAP = [];
  var i = 0;
  while (i < 8) {
    MAP[i] = [];
    SCHEMA_MAP[i] = [];
    var j = 0;
    while (j < 8) {
      MAP[i][j] = COLORS[7];
      SCHEMA_MAP[i][j] = 7;
      j++;
    }
    ++i;
  }

  function renderGrid() {
    ctx.fillStyle = COLORS[6];
    var i = 0;
    while (i < 7) {
      ++i;
      ctx.fillRect(i * 80 - 1, 0, 2, 640);
      ctx.fillRect(0, i * 80 - 1, 640, 2);
    }
  }

  // Top
  ctx.fillStyle = COLORS[7];
  ctx.fillRect(0,0,640,640);

  renderGrid();


  ctx.fillStyle = COLORS[0];

  ctx.font = "20px 'Cooper Heavy'";
  renderPalette();

  function renderPalette() {
    // Palette
    var i =0;
    while (i < 8) {
      ctx.fillStyle = COLORS[i];
      ctx.fillRect((i % 8) * 70, 640, 70, 70);
      ++i;
    }
    ctx.fillStyle = '#fafafa';
    ctx.fillRect(8*70, 640, 80, 100);
    ctx.fillStyle = COLORS[0];
    ctx.fillText('reroll', 578, 685);
    if (COLOR < 4) {
      ctx.strokeStyle = COLORS[7];
    }
    else {
      ctx.strokeStyle = COLORS[0];
    }
    ctx.strokeRect((COLOR % 8) * 70 + 1, 640 + 1, 68, 68);
  }

  function renderMap()
  {
    ctx.fillStyle = COLORS[7];
    ctx.fillRect(0,0,640,640);
    renderGrid();
    var i = 0;
    while (i < 8) {
      var j = 0;
      while (j < 8) {
        if (MAP[i][j] != COLORS[7]) {
          ctx.fillStyle = MAP[i][j];
          ctx.fillRect(i * 80, j * 80, 80, 80)
        }
        ++j;
      }
      ++i;
    }
  }



  canvas.addEventListener('mousedown', mouseDown);
  canvas.addEventListener('mouseup', mouseUp);
  canvas.addEventListener('mousemove', mouseMove);
  canvas.addEventListener('touchstart', touchstart);
  canvas.addEventListener('touchend', touchend);
  canvas.addEventListener('touchmove', touchmove);
  canvas.addEventListener('mouseout', mouseOut);

  var MOUSE = {
    x : 0,
    y : 0,
    down  :0
  }
  
  function touchstart(event){
    var e = event.touches[0];
    mouseDown(e);
    event.preventDefault();
    event.stopPropagation();
  }

  function touchend(event){
    var e = event.touches[0];
    mouseUp(e);
    event.preventDefault();
    event.stopPropagation();
  }

  function touchmove(event){
    var e = event.touches[0];
    mouseMove(e);
    event.preventDefault();
    event.stopPropagation();
  }

  function mouseOut(event) {
    MOUSE.down = 0;
  }

  function mouseDown(event) {
    var x = (event.clientX / (canvas.offsetWidth / WIDTH)) / 80 | 0;
    var y = (event.clientY / (canvas.offsetHeight / HEIGHT)) / 80 | 0;

    if (y < 8 ) {
      if (MAP[x][y] != COLORS[COLOR]) {
       draw(x, y);
      }
      MOUSE.x = x;
      MOUSE.y = y;
      MOUSE.down  = 1;
    }
    else {
      var x = (event.clientX / (canvas.offsetWidth / WIDTH)) / 70 | 0;
      selectColor(x, y);
    }
  }

  function mouseMove(event) {
    if (!MOUSE.down) {
      return;
    }
    var x = (event.clientX / (canvas.offsetWidth / WIDTH)) / 80 | 0;
    var y = (event.clientY / (canvas.offsetHeight / HEIGHT)) / 80 | 0;

    if (y < 8) {
      if (MAP[x][y] != COLORS[COLOR]) {
       draw(x, y);
      }
      MOUSE.x = x;
      MOUSE.y = y;
    }
  }

  function mouseUp(event) {
    MOUSE.down = 0;
  }

  




  function remixMap() {
    var i = 0;
    while (i < 8) {
      var j = 0;
      while (j < 8)
      {
        MAP[i][j] = COLORS[SCHEMA_MAP[i][j]];
        ++j;
      }
      ++i;
    }
  }

  function selectColor(x, y) {
    if (x  <8) {
     COLOR = x;
     COLOR_INDEX = x;
     renderPalette();
    }
    else {
      generatePalette();
      renderPalette();
      remixMap();
      COLOR = COLORS[COLOR_INDEX];
      renderMap();
      saveMap();
    }

  }

  function draw(x, y) {
    ctx.fillStyle = COLORS[COLOR];
    ctx.fillRect(x * 80, y * 80, 80, 80);
    MAP[x][y] = COLORS[COLOR];
    saveMap();
    SCHEMA_MAP[x][y] = COLOR;
  }  


</script>